<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ROSEndEffector: ROSEE::Utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSEndEffector
   </div>
   <div id="projectbrief">ROS End-Effector package: provides a ROS-based set of standard interfaces to command robotics end-effectors in an agnostic fashion.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceROSEE.html">ROSEE</a></li><li class="navelem"><a class="el" href="namespaceROSEE_1_1Utils.html">Utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ROSEE::Utils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structROSEE_1_1Utils_1_1DifferentKeysException.html">DifferentKeysException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROSEE_1_1Utils_1_1SecondOrderFilter.html">SecondOrderFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROSEE_1_1Utils_1_1Timer.html">Timer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abc2c5a794780396c406ea8ba7cc842e1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceROSEE_1_1Utils.html#abc2c5a794780396c406ea8ba7cc842e1">create_directory</a> (std::string pathDirectory)</td></tr>
<tr class="separator:abc2c5a794780396c406ea8ba7cc842e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fc6fa08b724637ed69eacb4ef0cbf6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceROSEE_1_1Utils.html#ac6fc6fa08b724637ed69eacb4ef0cbf6">out2file</a> (std::string pathFile, std::string output)</td></tr>
<tr class="separator:ac6fc6fa08b724637ed69eacb4ef0cbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac135017fc4a3b986665358fada3b65bb"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceROSEE_1_1Utils.html#ac135017fc4a3b986665358fada3b65bb">getFilesInDir</a> (std::string pathFolder)</td></tr>
<tr class="separator:ac135017fc4a3b986665358fada3b65bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8b2baa6146311f3b05224f84edef23"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceROSEE_1_1Utils.html#aba8b2baa6146311f3b05224f84edef23">binomial_coefficent</a> (int n, int k)</td></tr>
<tr class="separator:aba8b2baa6146311f3b05224f84edef23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f237326c153c934ef6eca34a2a638b3"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceROSEE_1_1Utils.html#a8f237326c153c934ef6eca34a2a638b3">getPackagePath</a> ()</td></tr>
<tr class="separator:a8f237326c153c934ef6eca34a2a638b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d318475c49a042e3b8c748edf5a7c3"><td class="memTemplParams" colspan="2">template&lt;class KeyType , class ValueType &gt; </td></tr>
<tr class="memitem:ad7d318475c49a042e3b8c748edf5a7c3"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; KeyType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROSEE_1_1Utils.html#ad7d318475c49a042e3b8c748edf5a7c3">extract_keys</a> (std::map&lt; KeyType, ValueType &gt; const &amp;input_map)</td></tr>
<tr class="separator:ad7d318475c49a042e3b8c748edf5a7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d45f067abee7b1c5a93808602489e0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa2d45f067abee7b1c5a93808602489e0"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROSEE_1_1Utils.html#aa2d45f067abee7b1c5a93808602489e0">extract_keys_merged</a> (std::map&lt; std::set&lt; std::string &gt;, T &gt; const &amp;input_map, unsigned int max_string_number=0)</td></tr>
<tr class="memdesc:aa2d45f067abee7b1c5a93808602489e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract all the string in the set keys of a map.  <a href="#aa2d45f067abee7b1c5a93808602489e0">More...</a><br /></td></tr>
<tr class="separator:aa2d45f067abee7b1c5a93808602489e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a22625fe5dac6f419263db21dfb827"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a11a22625fe5dac6f419263db21dfb827"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROSEE_1_1Utils.html#a11a22625fe5dac6f419263db21dfb827">extract_keys_merged</a> (std::map&lt; std::pair&lt; std::string, std::string &gt;, T &gt; const &amp;input_map, unsigned int max_string_number=0)</td></tr>
<tr class="memdesc:a11a22625fe5dac6f419263db21dfb827"><td class="mdescLeft">&#160;</td><td class="mdescRight">See above, this is the version with pair instead of set.  <a href="#a11a22625fe5dac6f419263db21dfb827">More...</a><br /></td></tr>
<tr class="separator:a11a22625fe5dac6f419263db21dfb827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcd0d367579ba11adf50e27a685b2d0"><td class="memTemplParams" colspan="2">template&lt;typename keyType , typename valueType1 , typename valueType2 &gt; </td></tr>
<tr class="memitem:a1fcd0d367579ba11adf50e27a685b2d0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROSEE_1_1Utils.html#a1fcd0d367579ba11adf50e27a685b2d0">keys_equal</a> (std::map&lt; keyType, valueType1 &gt; const &amp;lhs, std::map&lt; keyType, valueType2 &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a1fcd0d367579ba11adf50e27a685b2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return false if two maps have different keys.  <a href="#a1fcd0d367579ba11adf50e27a685b2d0">More...</a><br /></td></tr>
<tr class="separator:a1fcd0d367579ba11adf50e27a685b2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338a8bb3a31c03a07b1496396d6ed736"><td class="memTemplParams" colspan="2">template&lt;typename RetType , typename... Args&gt; </td></tr>
<tr class="memitem:a338a8bb3a31c03a07b1496396d6ed736"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; RetType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceROSEE_1_1Utils.html#a338a8bb3a31c03a07b1496396d6ed736">loadObject</a> (std::string lib_name, std::string function_name, Args...args)</td></tr>
<tr class="memdesc:a338a8bb3a31c03a07b1496396d6ed736"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceROSEE_1_1Utils.html">Utils</a> to dynamically load an object.  <a href="#a338a8bb3a31c03a07b1496396d6ed736">More...</a><br /></td></tr>
<tr class="separator:a338a8bb3a31c03a07b1496396d6ed736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7f78086d94e0b6effc2cb24d2cdf01"><td class="memItemLeft" align="right" valign="top">static std_msgs::Float32MultiArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceROSEE_1_1Utils.html#a9e7f78086d94e0b6effc2cb24d2cdf01">eigenMatrixToFloat32MultiArray</a> (Eigen::MatrixXd eigenMatrix)</td></tr>
<tr class="memdesc:a9e7f78086d94e0b6effc2cb24d2cdf01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to fill the Float32MultiArray ROS message from an eigen matrix.  <a href="#a9e7f78086d94e0b6effc2cb24d2cdf01">More...</a><br /></td></tr>
<tr class="separator:a9e7f78086d94e0b6effc2cb24d2cdf01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843c52094fde633962b2f101c72313a5"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceROSEE_1_1Utils.html#a843c52094fde633962b2f101c72313a5">eigenVectorToStdVector</a> (Eigen::VectorXd eigenVector)</td></tr>
<tr class="separator:a843c52094fde633962b2f101c72313a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0cad4fcf9d6444667dadc1807870573"><td class="memItemLeft" align="right" valign="top">static Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceROSEE_1_1Utils.html#ab0cad4fcf9d6444667dadc1807870573">yamlMatrixToEigen</a> (const YAML::Node &amp;matrixNode)</td></tr>
<tr class="memdesc:ab0cad4fcf9d6444667dadc1807870573"><td class="mdescLeft">&#160;</td><td class="mdescRight">given a yaml node with a structure like  <a href="#ab0cad4fcf9d6444667dadc1807870573">More...</a><br /></td></tr>
<tr class="separator:ab0cad4fcf9d6444667dadc1807870573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781452080c25c559256359ff9eae0303"><td class="memItemLeft" align="right" valign="top">static Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceROSEE_1_1Utils.html#a781452080c25c559256359ff9eae0303">yamlVectorToEigen</a> (const YAML::Node &amp;vectorNode)</td></tr>
<tr class="separator:a781452080c25c559256359ff9eae0303"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aba8b2baa6146311f3b05224f84edef23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int ROSEE::Utils::binomial_coefficent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Utils_8h_source.html#l00077">77</a> of file <a class="el" href="Utils_8h_source.html">Utils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;                                                    {</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <span class="keywordflow">if</span> (k == 0 || k == n){</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        <span class="keywordflow">return</span> 1;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    }</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceROSEE_1_1Utils.html#aba8b2baa6146311f3b05224f84edef23">Utils::binomial_coefficent</a>(n - 1, k - 1) + <a class="code" href="namespaceROSEE_1_1Utils.html#aba8b2baa6146311f3b05224f84edef23">Utils::binomial_coefficent</a>(n - 1, k);</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    </div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;}</div><div class="ttc" id="namespaceROSEE_1_1Utils_html_aba8b2baa6146311f3b05224f84edef23"><div class="ttname"><a href="namespaceROSEE_1_1Utils.html#aba8b2baa6146311f3b05224f84edef23">ROSEE::Utils::binomial_coefficent</a></div><div class="ttdeci">static int binomial_coefficent(int n, int k)</div><div class="ttdef"><b>Definition:</b> <a href="Utils_8h_source.html#l00077">Utils.h:77</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abc2c5a794780396c406ea8ba7cc842e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ROSEE::Utils::create_directory </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pathDirectory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Utils_8h_source.html#l00039">39</a> of file <a class="el" href="Utils_8h_source.html">Utils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;                                                     {</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    boost::filesystem::path path(pathDirectory);</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <span class="keywordflow">return</span> boost::filesystem::create_directories(path);</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9e7f78086d94e0b6effc2cb24d2cdf01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std_msgs::Float32MultiArray ROSEE::Utils::eigenMatrixToFloat32MultiArray </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>eigenMatrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility to fill the Float32MultiArray ROS message from an eigen matrix. </p>
<p>The Float32MultiArray matrix will be stored in column major, independently from the eigen matrix that can be row major (even by default eigen matrix is column major, it can be templatizate specifing the row major) </p>

<p>Definition at line <a class="el" href="UtilsEigen_8h_source.html#l00019">19</a> of file <a class="el" href="UtilsEigen_8h_source.html">UtilsEigen.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;                                                                                            {</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    </div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    std_msgs::Float32MultiArray rosMatrix;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    </div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nRow = eigenMatrix.rows();</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nCol = eigenMatrix.cols();</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = nRow*nCol;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    </div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    <span class="keywordflow">if</span> (size == 0){ <span class="comment">//no reason to continue</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;        std::cerr &lt;&lt; <span class="stringliteral">&quot;[Utils::eigenMatrixToFloat32MultiArray] eigenMatrix passed has size 0&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        <span class="keywordflow">return</span> rosMatrix;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    }</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    </div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    rosMatrix.layout.dim.push_back(std_msgs::MultiArrayDimension());</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    rosMatrix.layout.dim.push_back(std_msgs::MultiArrayDimension());</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    rosMatrix.layout.dim[0].label = <span class="stringliteral">&quot;column&quot;</span>;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    rosMatrix.layout.dim[0].size = nCol;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    rosMatrix.layout.dim[0].stride = nCol*nRow;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    </div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    rosMatrix.layout.dim[1].label = <span class="stringliteral">&quot;row&quot;</span>;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    rosMatrix.layout.dim[1].size = nRow;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    rosMatrix.layout.dim[1].stride = nRow;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    </div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    rosMatrix.layout.data_offset = 0;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;  </div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    rosMatrix.data.resize(size);</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keywordtype">int</span> posRow = 0;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iCol=0; iCol&lt;nCol; iCol++){</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iRow=0; iRow&lt;nRow; iRow++){</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;            posRow = iCol*nRow;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;            rosMatrix.data.at(posRow + iRow) = eigenMatrix(iRow,iCol);</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        }</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    }</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    </div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <span class="keywordflow">return</span> rosMatrix;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    </div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a843c52094fde633962b2f101c72313a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;float&gt; ROSEE::Utils::eigenVectorToStdVector </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd&#160;</td>
          <td class="paramname"><em>eigenVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="UtilsEigen_8h_source.html#l00058">58</a> of file <a class="el" href="UtilsEigen_8h_source.html">UtilsEigen.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;                                                                           {</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    </div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    std::vector&lt;float&gt; stdVect(eigenVector.data(), eigenVector.data() + eigenVector.size());</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    </div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <span class="keywordflow">return</span> stdVect;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad7d318475c49a042e3b8c748edf5a7c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType , class ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;KeyType&gt; ROSEE::Utils::extract_keys </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; KeyType, ValueType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Utils_8h_source.html#l00095">95</a> of file <a class="el" href="Utils_8h_source.html">Utils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;                                                                                    {</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  std::vector&lt;KeyType&gt; retval;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; element : input_map) {</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    retval.push_back(element.first);</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  }</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  <span class="keywordflow">return</span> retval;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa2d45f067abee7b1c5a93808602489e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::string&gt; ROSEE::Utils::extract_keys_merged </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::set&lt; std::string &gt;, T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_string_number</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract all the string in the set keys of a map. </p>
<p>All string are put togheter so the original meaning of each set is lost </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_map</td><td>the map where extract the keys </td></tr>
    <tr><td class="paramname">max_string_number</td><td>the max number of different string among all the set keys. Useful to not iterate all the map if not necessary. With default value = 0 all map is iterated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of extracted string of set keys (string in this vect will be unique) </dd></dl>

<p>Definition at line <a class="el" href="Utils_8h_source.html#l00113">113</a> of file <a class="el" href="Utils_8h_source.html">Utils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;                                                                                       {</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    </div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    std::set&lt;std::string&gt; allStrings;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    <span class="comment">// if else so we do not check in the for the max_string_number if it is not used (ie ==0)</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    <span class="keywordflow">if</span> (max_string_number == 0) {</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; element : input_map) {</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;            allStrings.insert( element.first.begin(), element.first.end() );</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        }</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;            </div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; element : input_map) {</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;            allStrings.insert(element.first.begin(), element.first.end());</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;            <span class="keywordflow">if</span> (max_string_number == allStrings.size()){</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;            }</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;            <span class="keywordflow">if</span> (max_string_number &lt; allStrings.size() ) {</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;                std::cerr &lt;&lt; <span class="stringliteral">&quot;[ERROR]&quot;</span> &lt;&lt; __func__ &lt;&lt; <span class="stringliteral">&quot; You passed &quot;</span> &lt;&lt; max_string_number</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;                &lt;&lt; <span class="stringliteral">&quot; but I found more unique strings in the set keys ( &quot;</span> &lt;&lt; allStrings.size()</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;                &lt;&lt; <span class="stringliteral">&quot; found)&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                <span class="keywordflow">return</span> std::vector&lt;std::string&gt;();</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;            }</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;        }</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    }</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    std::vector&lt;std::string&gt; retval (allStrings.begin(), allStrings.end());</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    <span class="keywordflow">return</span> retval;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a11a22625fe5dac6f419263db21dfb827"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::string&gt; ROSEE::Utils::extract_keys_merged </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::pair&lt; std::string, std::string &gt;, T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_string_number</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See above, this is the version with pair instead of set. </p>

<p>Definition at line <a class="el" href="Utils_8h_source.html#l00146">146</a> of file <a class="el" href="Utils_8h_source.html">Utils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                                                                                                  {</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    </div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    std::set&lt;std::string&gt; allStrings;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    <span class="comment">// if else so we do not check in the for the max_string_number if it is not used (ie ==0)</span></div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    <span class="keywordflow">if</span> (max_string_number == 0) {</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; element : input_map) {</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;            allStrings.insert( element.first.first);</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;            allStrings.insert( element.first.second);</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        }</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;            </div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; element : input_map) {</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;            allStrings.insert( element.first.first);</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;            allStrings.insert( element.first.second);</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;            <span class="keywordflow">if</span> (max_string_number == allStrings.size()){</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            }</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;            <span class="keywordflow">if</span> (max_string_number &lt; allStrings.size() ) {</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;                std::cerr &lt;&lt; <span class="stringliteral">&quot;[ERROR]&quot;</span> &lt;&lt; __func__ &lt;&lt; <span class="stringliteral">&quot; You passed &quot;</span> &lt;&lt; max_string_number</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;                &lt;&lt; <span class="stringliteral">&quot; but I found more unique strings in the pair keys ( &quot;</span> &lt;&lt; allStrings.size()</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                &lt;&lt; <span class="stringliteral">&quot; found)&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                <span class="keywordflow">return</span> std::vector&lt;std::string&gt;();</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;            }</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        }</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    }</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    std::vector&lt;std::string&gt; retval (allStrings.begin(), allStrings.end());</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    <span class="keywordflow">return</span> retval;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac135017fc4a3b986665358fada3b65bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::string&gt; ROSEE::Utils::getFilesInDir </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pathFolder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Utils_8h_source.html#l00055">55</a> of file <a class="el" href="Utils_8h_source.html">Utils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;                                                                    {</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    </div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    boost::filesystem::path p (pathFolder);</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    std::vector &lt;std::string&gt; retVect;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    </div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <span class="keywordflow">if</span> (! boost::filesystem::exists(p) ) {</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        std::cerr &lt;&lt; <span class="stringliteral">&quot;[ERROR &quot;</span> &lt;&lt; __func__ &lt;&lt; <span class="stringliteral">&quot;] path &#39;&quot;</span> &lt;&lt; pathFolder &lt;&lt; <span class="stringliteral">&quot;&#39; does not exists&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <span class="keywordflow">return</span> retVect;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    }</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    </div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keywordflow">if</span> (! boost::filesystem::is_directory(p)){ </div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        std::cerr &lt;&lt; <span class="stringliteral">&quot;[ERROR &quot;</span> &lt;&lt; __func__ &lt;&lt; <span class="stringliteral">&quot;] path &#39;&quot;</span> &lt;&lt; pathFolder &lt;&lt; <span class="stringliteral">&quot;&#39; is not a directory&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        <span class="keywordflow">return</span> retVect;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    }</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    </div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="keywordflow">for</span> (boost::filesystem::directory_entry&amp; x : boost::filesystem::directory_iterator(p)) {</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        retVect.push_back (x.path().filename().string() );</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    }</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    </div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <span class="keywordflow">return</span> retVect;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8f237326c153c934ef6eca34a2a638b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string ROSEE::Utils::getPackagePath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Utils_8h_source.html#l00087">87</a> of file <a class="el" href="Utils_8h_source.html">Utils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                                  {</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    </div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    boost::filesystem::path path(__FILE__);</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    path.remove_filename();</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    <span class="keywordflow">return</span> path.string() + <span class="stringliteral">&quot;/../../&quot;</span>;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1fcd0d367579ba11adf50e27a685b2d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType , typename valueType1 , typename valueType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ROSEE::Utils::keys_equal </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; keyType, valueType1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; keyType, valueType2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return false if two maps have different keys. </p>
<p>The type of the keys (<code>typename</code>) must be the same obviously, but the values (<code>valueType1</code> and <code>valueType2</code>) can be anything, because they are not considered </p>

<p>Definition at line <a class="el" href="Utils_8h_source.html#l00182">182</a> of file <a class="el" href="Utils_8h_source.html">Utils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                                                                                                  {</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    <span class="keyword">auto</span> pred = [] (decltype(*lhs.begin()) a, decltype(*rhs.begin()) b)</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                   { <span class="keywordflow">return</span> (a.first == b.first); };</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    <span class="keywordflow">return</span> lhs.size() == rhs.size()</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        &amp;&amp; std::equal(lhs.begin(), lhs.end(), rhs.begin(), pred);</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a338a8bb3a31c03a07b1496396d6ed736"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetType , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;RetType&gt; ROSEE::Utils::loadObject </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>lib_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>function_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceROSEE_1_1Utils.html">Utils</a> to dynamically load an object. </p>
<p>This is used to dynamically load a derived object from a node that only knows the base interface. For example, we call the create_object(ros::nodeHandle) method of a derived EEHAL class The object must be a library which will return a RetType pointer with the <code>function_name</code> This function will "convert" to smart pointer for convenience </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lib_name</td><td>the name of the compiled library (eg <a class="el" href="classROSEE_1_1DummyHal.html" title="Class representing an end-effector. ">DummyHal</a>). Do not add the suffix .so </td></tr>
    <tr><td class="paramname">function_name</td><td>The method of </td></tr>
    <tr><td class="paramname">lib_name</td><td>which will return a RetType*. </td></tr>
    <tr><td class="paramname">args</td><td>arguments for the <code>function_name</code> , if the case </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::shared_ptr&lt;RetType&gt; a pointer to the new created object </dd></dl>

<p>Definition at line <a class="el" href="Utils_8h_source.html#l00228">228</a> of file <a class="el" href="Utils_8h_source.html">Utils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;                                                  {</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    </div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    <span class="keywordflow">if</span> (lib_name.empty()) {</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        </div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        std::cerr &lt;&lt; <span class="stringliteral">&quot;[Utils::loadObject] ERROR: Please specify lib_name&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    } </div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    </div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    std::string lib_name_path = <span class="stringliteral">&quot;lib&quot;</span> + lib_name +<span class="stringliteral">&quot;.so&quot;</span>; </div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    <span class="comment">//clear old errors</span></div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    dlerror();</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    <span class="keywordtype">void</span>* lib_handle = dlopen(lib_name_path.c_str(), RTLD_LAZY);</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    <span class="keyword">auto</span> error = dlerror();</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    <span class="keywordflow">if</span> (!lib_handle || error != NULL) {</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;        std::cerr &lt;&lt; <span class="stringliteral">&quot;[Utils::loadObject] ERROR in opening the library: &quot;</span> &lt;&lt; error &lt;&lt; std::endl;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    }</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    </div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    <span class="comment">//clear old errors</span></div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    dlerror();</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    </div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    RetType* (*function)(Args... args);</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    <span class="keyword">function</span> = <span class="keyword">reinterpret_cast&lt;</span>RetType* (*)(Args... args)<span class="keyword">&gt;</span>(dlsym(lib_handle, function_name.c_str()));</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    error = dlerror();</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    <span class="keywordflow">if</span> ( error != NULL)  {</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;        std::cerr &lt;&lt; <span class="stringliteral">&quot;[Utils::loadObject] ERROR in returning the function: &quot;</span> &lt;&lt; error &lt;&lt; std::endl;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    }</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    </div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    RetType* objectRaw = <span class="keyword">function</span>(args...);</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    </div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    std::unique_ptr&lt;RetType&gt; objectPtr(objectRaw);</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    </div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    dlclose(lib_handle);</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    </div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    <span class="keywordflow">return</span> objectPtr;</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac6fc6fa08b724637ed69eacb4ef0cbf6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ROSEE::Utils::out2file </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pathFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Utils_8h_source.html#l00044">44</a> of file <a class="el" href="Utils_8h_source.html">Utils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;                                                             {</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    std::ofstream fout ( pathFile );</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    fout &lt;&lt; output;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab0cad4fcf9d6444667dadc1807870573"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Eigen::MatrixXd ROSEE::Utils::yamlMatrixToEigen </td>
          <td>(</td>
          <td class="paramtype">const YAML::Node &amp;&#160;</td>
          <td class="paramname"><em>matrixNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>given a yaml node with a structure like </p>
<ul>
<li>[1, 2, 3]</li>
<li>[4, 5, 6] "Convert" this structure into a eigen matrix</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>is there a better way to do this? </dd></dl>

<p>Definition at line <a class="el" href="UtilsYAML_8h_source.html#l00018">18</a> of file <a class="el" href="UtilsYAML_8h_source.html">UtilsYAML.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;                                                                   {</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;        </div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    <span class="comment">//note: they say adding row by row to eigen is tremendously slow,</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    <span class="comment">// so we use vector</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    std::vector&lt;std::vector&lt;float&gt;&gt; stdMat;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    stdMat = matrixNode.as&lt;std::vector&lt;std::vector&lt;float&gt;&gt;&gt;();</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    Eigen::MatrixXd eigenMat(stdMat.size(), stdMat.at(0).size());</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    </div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iRow = 0; iRow&lt;stdMat.size(); iRow++) {</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iCol = 0; iCol&lt;stdMat.at(0).size(); iCol++) {</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;            eigenMat(iRow, iCol) =  stdMat.at(iRow).at(iCol);</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;        }</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    }</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    </div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="keywordflow">return</span> eigenMat;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    </div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a781452080c25c559256359ff9eae0303"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Eigen::VectorXd ROSEE::Utils::yamlVectorToEigen </td>
          <td>(</td>
          <td class="paramtype">const YAML::Node &amp;&#160;</td>
          <td class="paramname"><em>vectorNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="UtilsYAML_8h_source.html#l00037">37</a> of file <a class="el" href="UtilsYAML_8h_source.html">UtilsYAML.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;                                                                   {</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        </div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <span class="comment">//note: they say adding row by row to eigen is tremendously slow,</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <span class="comment">// so we use vector</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    std::vector&lt;float&gt; stdVect;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    stdVect = vectorNode.as&lt;std::vector&lt;float&gt;&gt;();</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    Eigen::VectorXd eigenVec(stdVect.size());</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    </div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i&lt;stdVect.size(); i++) {</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        eigenVec(i) =  stdVect.at(i);</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    }</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    </div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="keywordflow">return</span> eigenVec;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    </div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 3 2022 05:19:50 for ROSEndEffector by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
